
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-park-mail-ru/2023_1_Seekers/internal/auth/delivery/http/handler.go (79.3%)</option>
				
				<option value="file1">github.com/go-park-mail-ru/2023_1_Seekers/internal/auth/delivery/http/register.go (0.0%)</option>
				
				<option value="file2">github.com/go-park-mail-ru/2023_1_Seekers/internal/auth/repository/inmemory/session.go (73.9%)</option>
				
				<option value="file3">github.com/go-park-mail-ru/2023_1_Seekers/internal/auth/usecase/usecase.go (72.9%)</option>
				
				<option value="file4">github.com/go-park-mail-ru/2023_1_Seekers/internal/mail/delivery/handler.go (63.6%)</option>
				
				<option value="file5">github.com/go-park-mail-ru/2023_1_Seekers/internal/mail/delivery/register.go (0.0%)</option>
				
				<option value="file6">github.com/go-park-mail-ru/2023_1_Seekers/internal/mail/repository/inmemory/inmemory.go (85.7%)</option>
				
				<option value="file7">github.com/go-park-mail-ru/2023_1_Seekers/internal/mail/usecase/usecase.go (81.8%)</option>
				
				<option value="file8">github.com/go-park-mail-ru/2023_1_Seekers/internal/middleware/middleware.go (65.2%)</option>
				
				<option value="file9">github.com/go-park-mail-ru/2023_1_Seekers/internal/user/repository/inmemory/repository.go (72.4%)</option>
				
				<option value="file10">github.com/go-park-mail-ru/2023_1_Seekers/internal/user/usecase/usecase.go (57.7%)</option>
				
				<option value="file11">github.com/go-park-mail-ru/2023_1_Seekers/pkg/errors/errors.go (33.3%)</option>
				
				<option value="file12">github.com/go-park-mail-ru/2023_1_Seekers/pkg/http_error.go (85.7%)</option>
				
				<option value="file13">github.com/go-park-mail-ru/2023_1_Seekers/pkg/logger.go (1.1%)</option>
				
				<option value="file14">github.com/go-park-mail-ru/2023_1_Seekers/pkg/rand.go (87.5%)</option>
				
				<option value="file15">github.com/go-park-mail-ru/2023_1_Seekers/pkg/send_json.go (50.0%)</option>
				
				<option value="file16">github.com/go-park-mail-ru/2023_1_Seekers/pkg/validation.go (77.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package http

import (
        "encoding/json"
        "fmt"
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/mail"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        _user "github.com/go-park-mail-ru/2023_1_Seekers/internal/user"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg"
        "github.com/go-playground/validator/v10"
        log "github.com/sirupsen/logrus"
        "io"
        "net/http"
        "time"
)

type handlers struct {
        authUC auth.UseCaseI
        userUC _user.UseCaseI
        mailUC mail.UseCaseI
}

func New(aUC auth.UseCaseI, uUC _user.UseCaseI, mUC mail.UseCaseI) auth.HandlersI <span class="cov10" title="2">{
        return &amp;handlers{
                authUC: aUC,
                userUC: uUC,
                mailUC: mUC,
        }
}</span>

func handleAuthErr(w http.ResponseWriter, r *http.Request, err error) <span class="cov1" title="1">{
        pkg.HandleError(w, r, auth.Errors[err], err)
}</span>

func setNewCookie(w http.ResponseWriter, session *models.Session) <span class="cov10" title="2">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     config.CookieName,
                Value:    session.SessionID,
                Expires:  time.Now().Add(config.CookieTTL),
                HttpOnly: true,
                Path:     config.CookiePath,
        })
}</span>

func delCookie(w http.ResponseWriter) <span class="cov1" title="1">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:    config.CookieName,
                Value:   "",
                Expires: time.Now().AddDate(0, 0, -1),
                Path:    config.CookiePath,
        })
}</span>

// SignUp godoc
// @Summary      SignUp
// @Description  user sign up
// @Tags     users
// @Accept         application/json
// @Produce  application/json
// @Param    user body models.FormSignUp true "user info"
// @Success  200 {object} models.User "user created"
// @Failure 401 {object} error "passwords dont match"
// @Failure 403 {object} error "invalid form"
// @Failure 403 {object} error "password too short"
// @Failure 409 {object} error "user already exists"
// @Failure 500 {object} error "failed to create profile"
// @Failure 500 {object} error "failed to create session"
// @Router   /signup [post]
func (h *handlers) SignUp(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        defer func(Body io.ReadCloser) </span><span class="cov1" title="1">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to close request: ", err)
                }</span>
        }(r.Body)

        <span class="cov1" title="1">form := models.FormSignUp{}
        if err := json.NewDecoder(r.Body).Decode(&amp;form); err != nil </span><span class="cov1" title="1">{
                handleAuthErr(w, r, auth.ErrInvalidForm)
                return
        }</span>

        <span class="cov1" title="1">validate := validator.New()
        if err := validate.Struct(form); err != nil </span><span class="cov0" title="0">{
                handleAuthErr(w, r, auth.ErrInvalidForm)
                return
        }</span>

        <span class="cov1" title="1">user, err := h.authUC.SignUp(form)
        if err != nil </span><span class="cov1" title="1">{
                if err == auth.ErrInvalidLogin || err == _user.ErrTooShortPw ||
                        err == auth.ErrPwDontMatch || err == auth.ErrFailedCreateProfile </span><span class="cov1" title="1">{
                        handleAuthErr(w, r, err)
                        return
                }</span>
                <span class="cov1" title="1">handleAuthErr(w, r, auth.ErrUserExists)
                return</span>
        }

        <span class="cov1" title="1">session, err := h.authUC.CreateSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                handleAuthErr(w, r, auth.ErrFailedCreateSession)
                return
        }</span>

        <span class="cov1" title="1">err = h.mailUC.CreateHelloMessage(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                handleAuthErr(w, r, auth.ErrInternalHelloMsg)
                return
        }</span>

        <span class="cov1" title="1">setNewCookie(w, session)
        pkg.SendJSON(w, http.StatusOK, user)</span>
}

// SignIn godoc
// @Summary      SignIn
// @Description  user sign in
// @Tags     users
// @Accept         application/json
// @Produce  application/json
// @Param    user body models.FormLogin true "user info"
// @Success  200 {object} models.User "user created"
// @Failure 401 {object} error "wrong password"
// @Failure 403 {object} error "invalid form"
// @Failure 500 {object} error "failed to create session"
// @Router   /signin [post]
func (h *handlers) SignIn(w http.ResponseWriter, r *http.Request) <span class="cov10" title="2">{
        defer func(Body io.ReadCloser) </span><span class="cov10" title="2">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Errorf("failed to close request: %w", err))
                }</span>
        }(r.Body)
        <span class="cov10" title="2">form := models.FormLogin{}

        err := json.NewDecoder(r.Body).Decode(&amp;form)
        if err != nil </span><span class="cov1" title="1">{
                handleAuthErr(w, r, auth.ErrInvalidForm)
                return
        }</span>

        <span class="cov10" title="2">user, err := h.authUC.SignIn(form)
        if err != nil </span><span class="cov1" title="1">{
                if err == auth.ErrInvalidLogin </span><span class="cov0" title="0">{
                        handleAuthErr(w, r, err)
                        return
                }</span>
                <span class="cov1" title="1">handleAuthErr(w, r, auth.ErrWrongPw)
                return</span>
        }

        // когда логинимся, то обновляем куку, если ранее была, то удалится и пересоздастся
        <span class="cov10" title="2">err = h.authUC.DeleteSessionByUID(user.ID)
        session, err := h.authUC.CreateSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                handleAuthErr(w, r, auth.ErrFailedCreateSession)
                return
        }</span>

        <span class="cov10" title="2">setNewCookie(w, session)
        pkg.SendJSON(w, http.StatusOK, user)</span>
}

// Logout godoc
// @Summary      Logout
// @Description  user log out
// @Tags     users
// @Accept         application/json
// @Produce  application/json
// @Success  200 "success logout"
// @Failure 401 {object} error "failed auth"
// @Failure 401 {object} error "failed get session"
// @Router   /logout [post]
func (h *handlers) Logout(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        delCookie(w)
        w.WriteHeader(http.StatusOK)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package http

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/middleware"
        "github.com/gorilla/mux"
        "net/http"
)

func RegisterHTTPRoutes(r *mux.Router, h auth.HandlersI, m *middleware.Middleware) <span class="cov0" title="0">{
        r.HandleFunc(config.RouteSignin, h.SignIn).Methods(http.MethodPost)
        r.HandleFunc(config.RouteSignup, h.SignUp).Methods(http.MethodPost)
        r.HandleFunc(config.RouteLogout, m.CheckAuth(h.Logout)).Methods(http.MethodGet)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package inmemory

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
)

type sessionsDB struct {
        sessions []models.Session
}

func New() auth.RepoI <span class="cov10" title="3">{
        return &amp;sessionsDB{
                []models.Session{
                        {1, "randgeneratedcookie12334524524523542"}, //уже есть сессия для Uid 1
                },
        }
}</span>

func (sDb *sessionsDB) CreateSession(s models.Session) error <span class="cov6" title="2">{
        if _, err := sDb.GetSessionByUID(s.UID); err == nil </span><span class="cov0" title="0">{
                return auth.ErrSessionExists
        }</span>
        <span class="cov6" title="2">sDb.sessions = append(sDb.sessions, s)
        return nil</span>
}

func (sDb *sessionsDB) DeleteSession(sessionID string) error <span class="cov0" title="0">{
        for i, s := range sDb.sessions </span><span class="cov0" title="0">{
                if s.SessionID == sessionID </span><span class="cov0" title="0">{
                        sDb.sessions = append(sDb.sessions[:i], sDb.sessions[i+1:]...)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return auth.ErrSessionNotFound</span>
}

func (sDb *sessionsDB) DeleteSessionByUID(uID uint64) error <span class="cov6" title="2">{
        for i, s := range sDb.sessions </span><span class="cov6" title="2">{
                if s.UID == uID </span><span class="cov6" title="2">{
                        sDb.sessions = append(sDb.sessions[:i], sDb.sessions[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov1" title="1">return auth.ErrSessionNotFound</span>
}

func (sDb *sessionsDB) GetSession(sessionID string) (*models.Session, error) <span class="cov10" title="3">{
        for _, s := range sDb.sessions </span><span class="cov10" title="3">{
                if s.SessionID == sessionID </span><span class="cov10" title="3">{
                        return &amp;s, nil
                }</span>
        }
        <span class="cov6" title="2">return nil, auth.ErrSessionNotFound</span>
}

func (sDb *sessionsDB) GetSessionByUID(uID uint64) (*models.Session, error) <span class="cov6" title="2">{
        for _, s := range sDb.sessions </span><span class="cov6" title="2">{
                if s.UID == uID </span><span class="cov6" title="2">{
                        return &amp;s, nil
                }</span>
        }
        <span class="cov6" title="2">return nil, auth.ErrSessionNotFound</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package usecase

import (
        "fmt"
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        _user "github.com/go-park-mail-ru/2023_1_Seekers/internal/user"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg"
)

type useCase struct {
        authRepo auth.RepoI
        userUC   _user.UseCaseI
}

func New(ar auth.RepoI, uc _user.UseCaseI) auth.UseCaseI <span class="cov10" title="3">{
        return &amp;useCase{
                authRepo: ar,
                userUC:   uc,
        }
}</span>

func (u *useCase) SignIn(form models.FormLogin) (*models.User, error) <span class="cov6" title="2">{
        email, err := pkg.ValidateLogin(form.Login)
        if err != nil </span><span class="cov0" title="0">{
                return nil, auth.ErrInvalidLogin
        }</span>
        <span class="cov6" title="2">user, err := u.userUC.GetUserByEmail(email)
        if err != nil </span><span class="cov1" title="1">{
                return nil, auth.ErrWrongPw
        }</span>

        <span class="cov6" title="2">if user.Password != form.Password </span><span class="cov0" title="0">{
                return nil, auth.ErrWrongPw
        }</span>

        <span class="cov6" title="2">return user, nil</span>
}

func (u *useCase) SignUp(form models.FormSignUp) (*models.User, error) <span class="cov1" title="1">{
        if form.RepeatPw != form.Password </span><span class="cov1" title="1">{
                return nil, auth.ErrPwDontMatch
        }</span>

        <span class="cov1" title="1">email, err := pkg.ValidateLogin(form.Login)
        if err != nil || len(form.Login) &gt; 30 || len(form.Login) &lt; 3 </span><span class="cov0" title="0">{
                return nil, auth.ErrInvalidLogin
        }</span>

        <span class="cov1" title="1">user, err := u.userUC.CreateUser(models.User{
                Email:    email,
                Password: form.Password,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("cant create user: %w", err)
        }</span>

        <span class="cov1" title="1">err = u.userUC.CreateProfile(models.Profile{
                UID:       user.ID,
                FirstName: form.FirstName,
                LastName:  form.LastName,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err = u.userUC.DeleteUser(*user); err == nil </span><span class="cov0" title="0">{
                        return nil, auth.ErrFailedCreateProfile
                }</span> else<span class="cov0" title="0"> {
                        return nil, auth.ErrInternal
                }</span>
        }

        <span class="cov1" title="1">return user, nil</span>
}

func (u *useCase) CreateSession(uID uint64) (*models.Session, error) <span class="cov6" title="2">{
        value, err := pkg.String(config.CookieLen)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cant create session: %w", err)
        }</span>
        <span class="cov6" title="2">newSession := models.Session{
                UID:       uID,
                SessionID: value,
        }

        err = u.authRepo.CreateSession(newSession)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cant create session: %w", err)
        }</span>

        <span class="cov6" title="2">return &amp;newSession, nil</span>
}

func (u *useCase) DeleteSession(sessionID string) error <span class="cov0" title="0">{
        err := u.authRepo.DeleteSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cant delete session: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (u *useCase) DeleteSessionByUID(uID uint64) error <span class="cov6" title="2">{
        err := u.authRepo.DeleteSessionByUID(uID)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("cant delete session by id: %w", err)
        }</span>

        <span class="cov6" title="2">return nil</span>
}

func (u *useCase) GetSession(sessionID string) (*models.Session, error) <span class="cov10" title="3">{
        s, err := u.authRepo.GetSession(sessionID)
        if err != nil </span><span class="cov6" title="2">{
                return nil, fmt.Errorf("cant get session: %w", err)
        }</span>

        <span class="cov10" title="3">return s, nil</span>
}

func (u *useCase) GetSessionByUID(uID uint64) (*models.Session, error) <span class="cov6" title="2">{
        s, err := u.authRepo.GetSessionByUID(uID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cant get session by user %w", err)
        }</span>

        <span class="cov6" title="2">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package delivery

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/mail"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg"
        "github.com/gorilla/mux"
        "net/http"
        "strconv"
)

type delivery struct {
        uc mail.UseCaseI
}

func New(uc mail.UseCaseI) mail.HandlersI <span class="cov8" title="1">{
        return &amp;delivery{
                uc: uc,
        }
}</span>

func handleMailErr(w http.ResponseWriter, r *http.Request, err error) <span class="cov8" title="1">{
        pkg.HandleError(w, r, mail.Errors[err], err)
}</span>

// GetInboxMessages godoc
// @Summary      GetInboxMessages
// @Description  List of incoming messages
// @Tags              messages
// @Accept         application/json
// @Produce  application/json
// @Success  200 {object} models.InboxResponse "success get list of incoming messages"
// @Failure 400 {object} error "failed to get user"
// @Failure 400 {object} error "failed to get inbox messages"
// @Failure 401 {object} error "failed auth"
// @Failure 401 {object} error "failed get session"
// @Router   /inbox/ [get]
func (del *delivery) GetInboxMessages(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, ok := r.Context().Value(pkg.ContextUser).(uint64)

        if !ok </span><span class="cov0" title="0">{
                handleMailErr(w, r, mail.ErrFailedGetUser)
                return
        }</span>

        <span class="cov8" title="1">messages, err := del.uc.GetIncomingMessages(userID)

        if err != nil </span><span class="cov0" title="0">{
                handleMailErr(w, r, mail.ErrFailedGetInboxMessages)
                return
        }</span>

        <span class="cov8" title="1">pkg.SendJSON(w, http.StatusOK, models.InboxResponse{
                Messages: messages,
        })</span>
}

// GetOutboxMessages godoc
// @Summary      GetOutboxMessages
// @Description  List of outgoing messages
// @Tags              messages
// @Accept         application/json
// @Produce  application/json
// @Success  200 {object} models.OutboxResponse "success get list of outgoing messages"
// @Failure 400 {object} error "failed to get user"
// @Failure 400 {object} error "failed to get outbox messages"
// @Failure 401 {object} error "failed auth"
// @Failure 401 {object} error "failed get session"
// @Router   /outbox/ [get]
func (del *delivery) GetOutboxMessages(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, ok := r.Context().Value(pkg.ContextUser).(uint64)
        if !ok </span><span class="cov0" title="0">{
                handleMailErr(w, r, mail.ErrFailedGetUser)
                return
        }</span>

        <span class="cov8" title="1">messages, err := del.uc.GetOutgoingMessages(userID)
        if err != nil </span><span class="cov0" title="0">{
                handleMailErr(w, r, mail.ErrFailedGetOutboxMessages)
                return
        }</span>

        <span class="cov8" title="1">pkg.SendJSON(w, http.StatusOK, models.OutboxResponse{
                Messages: messages,
        })</span>
}

// GetFolderMessages godoc
// @Summary      GetFolderMessages
// @Description  List of outgoing messages
// @Tags              messages
// @Accept         application/json
// @Produce  application/json
// @Param id path int true "FolderID"
// @Success  200 {object} models.FolderResponse "success get list of outgoing messages"
// @Failure 400 {object} error "failed to get user"
// @Failure 400 {object} error "failed to get folder messages"
// @Failure 401 {object} error "failed auth"
// @Failure 401 {object} error "failed get session"
// @Failure 404 {object} error "invalid url address"
// @Router   /folder/{id} [get]
func (del *delivery) GetFolderMessages(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, ok := r.Context().Value(pkg.ContextUser).(uint64)
        if !ok </span><span class="cov0" title="0">{
                handleMailErr(w, r, mail.ErrFailedGetUser)
                return
        }</span>
        <span class="cov8" title="1">vars := mux.Vars(r)
        folderID, err := strconv.ParseUint(vars["id"], 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                handleMailErr(w, r, mail.ErrInvalidURL)
                return
        }</span>

        <span class="cov8" title="1">folder, err := del.uc.GetFolderInfo(userID, folderID)

        if err != nil </span><span class="cov8" title="1">{
                handleMailErr(w, r, mail.ErrFailedGetFolderMessages)
                return
        }</span>

        <span class="cov8" title="1">messages, err := del.uc.GetFolderMessages(userID, folderID)

        if err != nil </span><span class="cov0" title="0">{
                handleMailErr(w, r, mail.ErrFailedGetFolderMessages)
                return
        }</span>

        <span class="cov8" title="1">pkg.SendJSON(w, http.StatusOK, models.FolderResponse{
                Folder:   *folder,
                Messages: messages,
        })</span>
}

// GetFolders godoc
// @Summary      GetFolders
// @Description  List of outgoing messages
// @Tags              messages
// @Accept         application/json
// @Produce  application/json
// @Success  200 {object} models.FoldersResponse "success get list of outgoing messages"
// @Failure 400 {object} error "failed to get user"
// @Failure 401 {object} error "failed auth"
// @Failure 401 {object} error "failed get session"
// @Router   /folders/ [get]
func (del *delivery) GetFolders(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, ok := r.Context().Value(pkg.ContextUser).(uint64)
        if !ok </span><span class="cov0" title="0">{
                handleMailErr(w, r, mail.ErrFailedGetUser)
                return
        }</span>

        <span class="cov8" title="1">folders := del.uc.GetFolders(userID)
        pkg.SendJSON(w, http.StatusOK, models.FoldersResponse{
                Folders: folders,
        })</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package delivery

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/mail"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/middleware"
        "github.com/gorilla/mux"
        "net/http"
)

func RegisterHTTPRoutes(r *mux.Router, h mail.HandlersI, m *middleware.Middleware) <span class="cov0" title="0">{
        r.HandleFunc(config.RouteInboxMessages, m.CheckAuth(h.GetInboxMessages)).Methods(http.MethodGet)
        r.HandleFunc(config.RouteOutboxMessages, m.CheckAuth(h.GetOutboxMessages)).Methods(http.MethodGet)
        r.HandleFunc(config.RouteFolderMessages, m.CheckAuth(h.GetFolderMessages)).Methods(http.MethodGet)
        r.HandleFunc(config.RouteFolders, m.CheckAuth(h.GetFolders)).Methods(http.MethodGet)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package inmemory

import (
        "errors"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/mail"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        _user "github.com/go-park-mail-ru/2023_1_Seekers/internal/user"
        "golang.org/x/exp/slices"
)

type mailDB struct {
        messages   []models.Message
        recipients []models.Recipient
        folders    []models.Folder
        boxes      []models.Box
        states     []models.State
        usersRepo  _user.RepoI
}

func New(ur _user.RepoI) mail.RepoI <span class="cov10" title="2">{
        return &amp;mailDB{
                messages: []models.Message{
                        {1, 2, "2023-01-01", "Invitation", "Hello, we decided to invite you to our party, lets go it will be fine!"},
                        {2, 3, "2023-01-02", "Spam letter", "Nunc non velit commodo, vestibulum enim ullamcorper, lobortis mi. Integer eu elit nibh. Integer bibendum semper arcu, eget consectetur nisi gravida eu. Suspendisse maximus id urna a volutpat. Quisque nec iaculis purus, non facilisis massa. Maecenas finibus dui ipsum, ut tempor sapien tincidunt blandit. Ut at iaculis eros, ultrices iaculis nibh. Mauris fermentum elit erat, at cursus urna euismod vel. In congue, ipsum a fermentum semper, dolor sem scelerisque leo, a tempus risus orci eu leo. Fusce vulputate venenatis imperdiet. Vestibulum interdum pellentesque facilisis"},
                        {3, 2, "2023-01-04", "Lorem", "Mauris imperdiet massa ante. Pellentesque feugiat nisl nec ultrices laoreet. Aenean a mauris mi. Sed auctor egestas nulla et vulputate. Praesent lobortis nulla ante, vel dignissim odio aliquet et. Suspendisse potenti. Donec venenatis nibh a sem consectetur, bibendum consectetur metus venenatis. Mauris lorem tellus, finibus id dui sit amet, facilisis fermentum orci. Mauris arcu ante, lacinia vitae orci in, tempus elementum lacus. Donec eu augue vulputate, tempor neque nec, efficitur purus. Mauris ut lorem non sapien placerat mattis. In in lacus a lorem viverra laoreet ut et orci. Maecenas auctor, justo nec hendrerit interdum, nibh nisi consectetur sapien, id ultrices lacus mi sed risus. "},
                        {4, 3, "2023-01-05", "Very interesting letter", "Morbi sit amet porttitor sapien, eget venenatis est. Suspendisse sollicitudin elit velit, quis sodales dolor maximus id. Vestibulum gravida scelerisque nibh, sit amet tincidunt augue gravida nec. Maecenas non placerat justo, at feugiat nulla. Phasellus dapibus a mi ut interdum. Aliquam nec quam feugiat, rutrum urna ut, cursus purus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. "},
                        {5, 2, "2023-01-06", "Small text letter", "Hi! how are you?"},
                        {6, 3, "2023-01-06", "Do you like to read books?", "We have a lot of new books that may interest you"},
                        {7, 2, "2023-01-07", "Advertisement", "Hi, visit our shop!"},
                        {8, 3, "2023-01-29", "Let's get acquainted", "It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout"},
                        {9, 1, "2023-01-29", "Not spam", "Open this letter please"},
                        {10, 1, "2023-01-01", "Vacancy", "We will be glad to offer you this job"},
                        {11, 1, "2023-01-01", "Invitation", "Hello, we decided to invite you to our party, lets go it will be fine!"},
                        {12, 1, "2023-01-02", "Spam letter", "Nunc non velit commodo, vestibulum enim ullamcorper, lobortis mi. Integer eu elit nibh. Integer bibendum semper arcu, eget consectetur nisi gravida eu. Suspendisse maximus id urna a volutpat. Quisque nec iaculis purus, non facilisis massa. Maecenas finibus dui ipsum, ut tempor sapien tincidunt blandit. Ut at iaculis eros, ultrices iaculis nibh. Mauris fermentum elit erat, at cursus urna euismod vel. In congue, ipsum a fermentum semper, dolor sem scelerisque leo, a tempus risus orci eu leo. Fusce vulputate venenatis imperdiet. Vestibulum interdum pellentesque facilisis"},
                        {13, 1, "2023-01-04", "Lorem", "Mauris imperdiet massa ante. Pellentesque feugiat nisl nec ultrices laoreet. Aenean a mauris mi. Sed auctor egestas nulla et vulputate. Praesent lobortis nulla ante, vel dignissim odio aliquet et. Suspendisse potenti. Donec venenatis nibh a sem consectetur, bibendum consectetur metus venenatis. Mauris lorem tellus, finibus id dui sit amet, facilisis fermentum orci. Mauris arcu ante, lacinia vitae orci in, tempus elementum lacus. Donec eu augue vulputate, tempor neque nec, efficitur purus. Mauris ut lorem non sapien placerat mattis. In in lacus a lorem viverra laoreet ut et orci. Maecenas auctor, justo nec hendrerit interdum, nibh nisi consectetur sapien, id ultrices lacus mi sed risus. "},
                        {14, 1, "2023-01-05", "Very interesting letter", "Morbi sit amet porttitor sapien, eget venenatis est. Suspendisse sollicitudin elit velit, quis sodales dolor maximus id. Vestibulum gravida scelerisque nibh, sit amet tincidunt augue gravida nec. Maecenas non placerat justo, at feugiat nulla. Phasellus dapibus a mi ut interdum. Aliquam nec quam feugiat, rutrum urna ut, cursus purus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. "},
                        {15, 1, "2023-01-06", "Small text letter", "Hi! how are you?"},
                        {16, 1, "2023-01-06", "Not spam", "Open this letter please"},
                        {17, 1, "2023-01-07", "Advertisement", "Hi, visit our shop!"},
                        {18, 2, "2023-01-29", "Donate", "There are many variations of passages of Lorem Ipsum available, but the majority."},
                        {19, 2, "2023-01-29", "Standart", "All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary."},
                        {20, 3, "2023-01-01", "Scope", "it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia."},
                        //{5, 2, "2023-03-01", "Title5", "Text5"},
                },
                recipients: []models.Recipient{
                        {1, 1},
                        {2, 1},
                        {3, 1},
                        {4, 1},
                        {5, 1},
                        {6, 1},
                        {7, 1},
                        {8, 1},
                        {9, 3},
                        {10, 2},
                        {11, 3},
                        {12, 2},
                        {13, 3},
                        {14, 2},
                        {15, 3},
                        {16, 2},
                        {17, 3},
                        {18, 3},
                        {19, 3},
                        {20, 1},
                },
                folders: []models.Folder{
                        {1, "Trash", 1},
                        {2, "Spam", 1},
                        {3, "Trash", 2},
                        {4, "Spam", 2},
                        {5, "Trash", 3},
                        {6, "Spam", 3},
                        {7, "My", 2},
                        {8, "Empty", 3},
                        {5, "Trash", 4},
                        {6, "Spam", 4},
                },
                boxes: []models.Box{
                        {7, 1},
                },
                states: []models.State{
                        {1, 1, false, false, true},
                        {2, 1, true, false, true},
                        {1, 2, false, false, true},
                        {3, 2, true, false, true},
                        {1, 3, false, false, true},
                        {2, 3, true, false, true},
                        {1, 4, false, false, true},
                        {3, 4, true, false, true},
                        {1, 5, false, false, true},
                        {2, 5, true, false, true},
                        {1, 6, false, false, true},
                        {3, 6, true, false, true},
                        {1, 7, false, false, true},
                        {2, 7, true, false, true},
                        {1, 8, false, false, true},
                        {3, 8, true, false, true},
                        {3, 9, false, false, true},
                        {1, 9, true, false, true},
                        {2, 10, false, false, true},
                        {1, 10, true, false, true},
                        {3, 11, false, false, true},
                        {1, 11, true, false, true},
                        {2, 12, false, false, true},
                        {1, 12, true, false, true},
                        {3, 13, false, false, true},
                        {1, 13, true, false, true},
                        {2, 14, false, false, true},
                        {1, 14, true, false, true},
                        {3, 15, false, false, true},
                        {1, 15, true, false, true},
                        {2, 16, false, false, true},
                        {1, 16, true, false, true},
                        {3, 17, false, false, true},
                        {1, 17, true, false, true},
                        {3, 18, false, false, true},
                        {2, 18, true, false, true},
                        {3, 19, false, false, true},
                        {2, 19, true, false, true},
                        {1, 20, false, false, true},
                        {3, 20, true, false, true},
                },
                usersRepo: ur,
        }
}</span>

func (db *mailDB) messageHasFolder(userID uint64, messageID uint64) bool <span class="cov1" title="1">{
        for _, b := range db.boxes </span><span class="cov1" title="1">{
                if b.MessageID == messageID </span><span class="cov1" title="1">{
                        idx := slices.IndexFunc(db.folders, func(folder models.Folder) bool </span><span class="cov1" title="1">{
                                return folder.FolderID == b.FolderID
                        }</span>)

                        <span class="cov1" title="1">if idx != -1 &amp;&amp; db.folders[idx].UserID == userID </span><span class="cov1" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov1" title="1">return false</span>
}

func (db *mailDB) findOriginalMessage(messageID uint64) (*models.Message, error) <span class="cov1" title="1">{
        idx := slices.IndexFunc(db.messages, func(message models.Message) bool </span><span class="cov1" title="1">{
                return message.MessageID == messageID
        }</span>)

        <span class="cov1" title="1">if idx == -1 </span><span class="cov0" title="0">{
                return nil, errors.New("message not found")
        }</span>

        <span class="cov1" title="1">return &amp;db.messages[idx], nil</span>
}

func (db *mailDB) findState(userID uint64, messageID uint64) (*models.State, error) <span class="cov1" title="1">{
        idx := slices.IndexFunc(db.states, func(state models.State) bool </span><span class="cov1" title="1">{
                return state.UserID == userID &amp;&amp; state.MessageID == messageID
        }</span>)

        <span class="cov1" title="1">if idx == -1 </span><span class="cov0" title="0">{
                return nil, errors.New("state not found")
        }</span>

        <span class="cov1" title="1">return &amp;db.states[idx], nil</span>
}

func (db *mailDB) findRecipientsEmails(messageID uint64) ([]string, error) <span class="cov1" title="1">{
        var recipientsEmails []string

        for _, r := range db.recipients </span><span class="cov1" title="1">{
                if r.MessageID == messageID </span><span class="cov1" title="1">{
                        user, err := db.usersRepo.GetUserByID(r.UserID)

                        if err != nil </span><span class="cov0" title="0">{
                                return recipientsEmails, err
                        }</span>

                        <span class="cov1" title="1">recipientsEmails = append(recipientsEmails, user.Email)</span>
                }
        }

        <span class="cov1" title="1">return recipientsEmails, nil</span>
}

func (db *mailDB) SelectIncomingMessagesByUser(userID uint64) ([]models.IncomingMessage, error) <span class="cov1" title="1">{
        var messages []models.IncomingMessage

        for _, r := range db.recipients </span><span class="cov1" title="1">{
                if r.UserID == userID </span><span class="cov1" title="1">{
                        if db.messageHasFolder(r.UserID, r.MessageID) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov1" title="1">originalMessage, err := db.findOriginalMessage(r.MessageID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov1" title="1">fromUser, err := db.usersRepo.GetUserByID(originalMessage.UserID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov1" title="1">state, err := db.findState(r.UserID, r.MessageID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov1" title="1">currentMessage := models.IncomingMessage{
                                MessageID:    r.MessageID,
                                FromUser:     fromUser.Email,
                                CreatingDate: originalMessage.CreatingDate,
                                Title:        originalMessage.Title,
                                Text:         originalMessage.Text,
                                Read:         state.Read,
                                Favorite:     state.Favorite,
                        }

                        messages = append(messages, currentMessage)</span>
                }
        }

        <span class="cov1" title="1">return messages, nil</span>
}

func (db *mailDB) SelectOutgoingMessagesByUser(userID uint64) ([]models.OutgoingMessage, error) <span class="cov1" title="1">{
        var messages []models.OutgoingMessage

        for _, m := range db.messages </span><span class="cov1" title="1">{
                if m.UserID == userID </span><span class="cov1" title="1">{
                        if db.messageHasFolder(userID, m.MessageID) </span><span class="cov1" title="1">{
                                continue</span>
                        }

                        <span class="cov1" title="1">recipients, err := db.findRecipientsEmails(m.MessageID)

                        if len(recipients) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov1" title="1">state, err := db.findState(userID, m.MessageID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov1" title="1">currentMessage := models.OutgoingMessage{
                                MessageID:    m.MessageID,
                                ToUsers:      recipients,
                                CreatingDate: m.CreatingDate,
                                Title:        m.Title,
                                Text:         m.Text,
                                Read:         state.Read,
                                Favorite:     state.Favorite,
                        }

                        messages = append(messages, currentMessage)</span>
                }
        }

        <span class="cov1" title="1">return messages, nil</span>
}

func (db *mailDB) SelectFolderByUserNFolder(userID uint64, folderID uint64) (*models.Folder, error) <span class="cov1" title="1">{
        idx := slices.IndexFunc(db.folders, func(folder models.Folder) bool </span><span class="cov1" title="1">{
                return folder.UserID == userID &amp;&amp; folder.FolderID == folderID
        }</span>)

        <span class="cov1" title="1">if idx == -1 </span><span class="cov1" title="1">{
                return nil, errors.New("folder not found")
        }</span>

        <span class="cov1" title="1">return &amp;db.folders[idx], nil</span>
}

func (db *mailDB) SelectFoldersByUser(userID uint64) []models.Folder <span class="cov1" title="1">{
        var folders []models.Folder

        for _, f := range db.folders </span><span class="cov1" title="1">{
                if f.UserID == userID </span><span class="cov1" title="1">{
                        folders = append(folders, f)
                }</span>
        }

        <span class="cov1" title="1">return folders</span>
}

func (db *mailDB) SelectMessagesByUserNFolder(userID uint64, folderID uint64) ([]models.IncomingMessage, error) <span class="cov1" title="1">{
        var messages []models.IncomingMessage

        for _, b := range db.boxes </span><span class="cov1" title="1">{
                if b.FolderID == folderID </span><span class="cov1" title="1">{
                        originalMessage, err := db.findOriginalMessage(b.MessageID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov1" title="1">fromUser, err := db.usersRepo.GetUserByID(originalMessage.UserID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov1" title="1">state, err := db.findState(userID, b.MessageID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov1" title="1">currentMessage := models.IncomingMessage{
                                MessageID:    b.MessageID,
                                FromUser:     fromUser.Email,
                                CreatingDate: originalMessage.CreatingDate,
                                Title:        originalMessage.Title,
                                Text:         originalMessage.Text,
                                Read:         state.Read,
                                Favorite:     state.Favorite,
                        }

                        messages = append(messages, currentMessage)</span>
                }
        }

        <span class="cov1" title="1">return messages, nil</span>
}

func (db *mailDB) CreateMessage(message models.Message, to ...uint64) error <span class="cov1" title="1">{
        message.MessageID = uint64(len(db.messages) + 1)
        db.messages = append(db.messages, message)
        for _, uid := range to </span><span class="cov1" title="1">{
                db.recipients = append(db.recipients, models.Recipient{
                        MessageID: message.MessageID,
                        UserID:    uid,
                })
                db.states = append(db.states, models.State{
                        UserID:    uid,
                        MessageID: message.MessageID,
                        Read:      false,
                        Favorite:  false,
                        Send:      true,
                })
        }</span>
        <span class="cov1" title="1">db.states = append(db.states, models.State{
                UserID:    message.UserID,
                MessageID: message.MessageID,
                Read:      true,
                Favorite:  false,
                Send:      true,
        })

        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package usecase

import (
        "errors"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/mail"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        "time"
)

type UseCase struct {
        repo mail.RepoI
}

func New(rep mail.RepoI) mail.UseCaseI <span class="cov10" title="2">{
        return &amp;UseCase{
                repo: rep,
        }
}</span>

func (uc *UseCase) GetFolders(userID uint64) []models.Folder <span class="cov1" title="1">{
        folders := uc.repo.SelectFoldersByUser(userID)

        return folders
}</span>

func (uc *UseCase) GetIncomingMessages(userID uint64) ([]models.IncomingMessage, error) <span class="cov1" title="1">{
        var messages []models.IncomingMessage
        messages, err := uc.repo.SelectIncomingMessagesByUser(userID)

        if err != nil </span><span class="cov0" title="0">{
                return messages, err
        }</span>

        <span class="cov1" title="1">return messages, nil</span>
}

func (uc *UseCase) GetOutgoingMessages(userID uint64) ([]models.OutgoingMessage, error) <span class="cov1" title="1">{
        var messages []models.OutgoingMessage
        messages, err := uc.repo.SelectOutgoingMessagesByUser(userID)

        if err != nil </span><span class="cov0" title="0">{
                return messages, err
        }</span>

        <span class="cov1" title="1">return messages, nil</span>
}

func (uc *UseCase) GetFolderMessages(userID uint64, folderID uint64) ([]models.IncomingMessage, error) <span class="cov1" title="1">{
        var messages []models.IncomingMessage

        folder, err := uc.repo.SelectFolderByUserNFolder(userID, folderID)

        if err != nil </span><span class="cov0" title="0">{
                return messages, err
        }</span>

        <span class="cov1" title="1">if folder == nil </span><span class="cov0" title="0">{
                return messages, errors.New("folder not found")
        }</span>

        <span class="cov1" title="1">messages, err = uc.repo.SelectMessagesByUserNFolder(userID, folderID)

        if err != nil </span><span class="cov0" title="0">{
                return messages, err
        }</span>

        <span class="cov1" title="1">return messages, nil</span>
}

func (uc *UseCase) GetFolderInfo(userID uint64, folderID uint64) (*models.Folder, error) <span class="cov1" title="1">{

        folder, err := uc.repo.SelectFolderByUserNFolder(userID, folderID)

        if err != nil </span><span class="cov1" title="1">{
                return folder, err
        }</span>

        <span class="cov1" title="1">if folder == nil </span><span class="cov0" title="0">{
                return folder, errors.New("folder not found")
        }</span>

        <span class="cov1" title="1">return folder, nil</span>
}

func (uc *UseCase) CreateHelloMessage(to uint64) error <span class="cov1" title="1">{
        now := time.Now()
        msg := models.Message{
                UserID:       0,
                CreatingDate: now.Format("2006-02-01"),
                Title:        "Hello! Its your first mail",
                Text:         "Support of mail box is glad to see You here! Have a nice day!",
        }
        return uc.CreateMessage(msg, to)
}</span>

func (uc *UseCase) CreateMessage(message models.Message, to ...uint64) error <span class="cov1" title="1">{
        return uc.repo.CreateMessage(message, to...)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "context"
        "fmt"
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg"
        "github.com/rs/cors"
        "net/http"
)

type Middleware struct {
        uc  auth.UseCaseI
        log *pkg.Logger
}

func New(aUc auth.UseCaseI, l *pkg.Logger) *Middleware <span class="cov10" title="3">{
        return &amp;Middleware{aUc, l}
}</span>

func (m *Middleware) Cors(h http.Handler) http.Handler <span class="cov0" title="0">{
        c := cors.New(cors.Options{
                AllowedMethods:   config.AllowedMethods,
                AllowedOrigins:   config.AllowedOrigins,
                AllowCredentials: true,
                AllowedHeaders:   config.AllowedHeaders,
        })
        return c.Handler(h)
}</span>

func (m *Middleware) HandlerLogger(h http.Handler) http.Handler <span class="cov0" title="0">{
        handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                handlerLogger := m.log.LoggerWithFields(map[string]any{
                        "method": r.Method,
                        "url":    r.URL.Path,
                })
                handlerLogger.Info("new request")
                r = r.WithContext(context.WithValue(r.Context(), pkg.ContextHandlerLog, handlerLogger))
                h.ServeHTTP(w, r)
        }</span>)
        <span class="cov0" title="0">return handler</span>
}

func (m *Middleware) CheckAuth(h http.HandlerFunc) http.HandlerFunc <span class="cov10" title="3">{
        handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="3">{
                cookie, err := r.Cookie(config.CookieName)
                if err != nil </span><span class="cov6" title="2">{
                        wrappedErr := fmt.Errorf("%v: %w", auth.ErrFailedAuth, err)
                        pkg.HandleError(w, r, auth.Errors[auth.ErrFailedAuth], wrappedErr)
                        return
                }</span>
                <span class="cov10" title="3">session, err := m.uc.GetSession(cookie.Value)
                if err != nil </span><span class="cov6" title="2">{
                        wrappedErr := fmt.Errorf("%v: %w", auth.ErrFailedGetSession, err)
                        pkg.HandleError(w, r, auth.Errors[auth.ErrFailedGetSession], wrappedErr)
                        return
                }</span>

                <span class="cov10" title="3">r = r.WithContext(context.WithValue(r.Context(), pkg.ContextUser, session.UID))

                h.ServeHTTP(w, r)</span>
        })
        <span class="cov10" title="3">return handler</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package inmemory

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/user"
)

type usersDB struct {
        users    []models.User
        profiles []models.Profile
}

func New() user.RepoI <span class="cov10" title="3">{
        return &amp;usersDB{
                []models.User{
                        {0, "support@mailbox.ru", "very_difficult_pw"},
                        {1, "test@mailbox.ru", "12345"},
                        {2, "gena@mailbox.ru", "54321"},
                        {3, "max@mailbox.ru", "13795"},
                        {4, "valera@mailbox.ru", "12345"},
                },
                []models.Profile{
                        {1, "Michail", "Testov"},
                        {2, "Ivan", "Ivanov"},
                        {3, "Michail", "Sidorov"},
                },
        }
}</span>

func (uDb *usersDB) GetUserByID(id uint64) (*models.User, error) <span class="cov1" title="1">{
        for i, u := range uDb.users </span><span class="cov1" title="1">{
                if u.ID == id </span><span class="cov1" title="1">{
                        return &amp;uDb.users[i], nil
                }</span>
        }
        <span class="cov0" title="0">return nil, auth.ErrUserNotFound</span>
}

func (uDb *usersDB) GetUserByEmail(email string) (*models.User, error) <span class="cov6" title="2">{
        for i, u := range uDb.users </span><span class="cov6" title="2">{
                if u.Email == email </span><span class="cov6" title="2">{
                        return &amp;uDb.users[i], nil
                }</span>
        }
        <span class="cov1" title="1">return nil, auth.ErrUserNotFound</span>
}

func (uDb *usersDB) CreateUser(user models.User) (*models.User, error) <span class="cov1" title="1">{
        _, err := uDb.GetUserByEmail(user.Email)
        if err == nil </span><span class="cov1" title="1">{
                return nil, auth.ErrUserExists
        }</span>
        //слой бд отвечает за присваивание id
        // TODO hash pw
        <span class="cov1" title="1">user.ID = uint64(len(uDb.users) + 1)
        uDb.users = append(uDb.users, user)
        return &amp;user, nil</span>
}

func (uDb *usersDB) DeleteUser(user models.User) error <span class="cov0" title="0">{
        for i, u := range uDb.users </span><span class="cov0" title="0">{
                if u.ID == user.ID </span><span class="cov0" title="0">{
                        uDb.users = append(uDb.users[:i], uDb.users[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return auth.ErrUserNotFound</span>
}

func (uDb *usersDB) GetProfileByID(id uint64) (*models.Profile, error) <span class="cov1" title="1">{
        for i, p := range uDb.profiles </span><span class="cov1" title="1">{
                if p.UID == id </span><span class="cov0" title="0">{
                        return &amp;uDb.profiles[i], nil
                }</span>
        }
        <span class="cov1" title="1">return nil, user.ErrUserNotFound</span>
}

func (uDb *usersDB) CreateProfile(profile models.Profile) error <span class="cov1" title="1">{
        _, err := uDb.GetProfileByID(profile.UID)
        if err == nil </span><span class="cov0" title="0">{
                return user.ErrUserExists
        }</span>
        <span class="cov1" title="1">uDb.profiles = append(uDb.profiles, profile)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package usecase

import (
        "fmt"
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        _user "github.com/go-park-mail-ru/2023_1_Seekers/internal/user"
        "github.com/go-playground/validator/v10"
        "net/mail"
)

type useCase struct {
        userRepo _user.RepoI
}

func New(r _user.RepoI) _user.UseCaseI <span class="cov10" title="3">{
        return &amp;useCase{userRepo: r}
}</span>

func validMailAddress(email string) (string, bool) <span class="cov1" title="1">{
        addr, err := mail.ParseAddress(email)
        if err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov1" title="1">return addr.Address, true</span>
}

func (u *useCase) CreateUser(user models.User) (*models.User, error) <span class="cov1" title="1">{
        validate := validator.New()
        err := validate.Struct(user)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(5)
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>
        <span class="cov1" title="1">if len(user.Password) &lt; config.PasswordMinLen </span><span class="cov0" title="0">{
                fmt.Println(6)
                return nil, _user.ErrTooShortPw
        }</span>
        <span class="cov1" title="1">if _, ok := validMailAddress(user.Email); !ok </span><span class="cov0" title="0">{
                fmt.Println(7)
                return nil, _user.ErrInvalidEmail
        }</span>
        <span class="cov1" title="1">return u.userRepo.CreateUser(user)</span>
}

func (u *useCase) DeleteUser(user models.User) error <span class="cov0" title="0">{
        return u.userRepo.DeleteUser(user)
}</span>

func (u *useCase) GetUserByID(ID uint64) (*models.User, error) <span class="cov0" title="0">{
        return u.userRepo.GetUserByID(ID)
}</span>

func (u *useCase) GetUserByEmail(email string) (*models.User, error) <span class="cov6" title="2">{
        return u.userRepo.GetUserByEmail(email)
}</span>

func (u *useCase) CreateProfile(profile models.Profile) error <span class="cov1" title="1">{
        validate := validator.New()
        err := validate.Struct(profile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create profile: %w", err)
        }</span>
        <span class="cov1" title="1">return u.userRepo.CreateProfile(profile)</span>
}
func (u *useCase) GetProfileByID(id uint64) (*models.Profile, error) <span class="cov0" title="0">{
        return u.userRepo.GetProfileByID(id)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package errors

type JSONError struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

func (err *JSONError) Error() string <span class="cov0" title="0">{
        return err.Message
}</span>

func New(code int, err error) *JSONError <span class="cov10" title="3">{
        return &amp;JSONError{
                Code:    code,
                Message: err.Error(),
        }
}</span>

func NewWrappedErr(code int, message string, err error) *JSONError <span class="cov0" title="0">{
        return &amp;JSONError{
                Code:    code,
                Message: message + " : " + err.Error(),
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package pkg

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg/errors"
        log "github.com/sirupsen/logrus"
        "net/http"
)

func SendError(w http.ResponseWriter, error *errors.JSONError) <span class="cov10" title="3">{
        SendJSON(w, error.Code, error)
}</span>

func HandleError(w http.ResponseWriter, r *http.Request, status int, err error) <span class="cov10" title="3">{
        customErr := errors.New(status, err)
        logger, ok := r.Context().Value(ContextHandlerLog).(*Logger)
        if !ok </span><span class="cov10" title="3">{
                log.Error("failed to get logger for handler", r.URL.Path)
        }</span> else<span class="cov0" title="0"> {
                logger.Error(err)
        }</span>
        <span class="cov10" title="3">SendError(w, customErr)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package pkg

import (
        "bytes"
        "fmt"
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/sirupsen/logrus"
        "io"
        "os"
        "runtime"
        "sort"
        "strings"
        "time"
)

type logHook struct {
        Writers   []io.Writer
        LogLevels []logrus.Level
}

func (h *logHook) Fire(entry *logrus.Entry) error <span class="cov0" title="0">{
        line, err := entry.String()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, w := range h.Writers </span><span class="cov0" title="0">{
                if _, err = w.Write([]byte(line)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (h *logHook) Levels() []logrus.Level <span class="cov0" title="0">{
        return h.LogLevels
}</span>

var logEntry *logrus.Entry

type Logger struct {
        *logrus.Entry
}

func GetLogger() *Logger <span class="cov10" title="3">{
        return &amp;Logger{logEntry}
}</span>

func (l *Logger) LoggerWithFields(fields map[string]any) *Logger <span class="cov0" title="0">{
        return &amp;Logger{l.WithFields(fields)}
}</span>

func (l *Logger) LoggerWithField(key string, val any) *Logger <span class="cov0" title="0">{
        return &amp;Logger{l.WithField(key, val)}
}</span>

func InitLogger() <span class="cov0" title="0">{
        l := logrus.New()
        loc, err := time.LoadLocation("Europe/Moscow")
        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Error: cant load time location")
        }</span>

        <span class="cov0" title="0">now := time.Now().In(loc)
        logsFName := config.LogsDir + config.LogsFileName + now.Format(config.LogsTimeFormat) + ".log"

        l.SetReportCaller(true)
        l.SetFormatter(&amp;Formatter{
                TimeFormat:  config.LogsTimeFormat,
                Colors:      true,
                Caller:      true,
                FieldsSpace: true,
                CustomCallerFormatter: func(f *runtime.Frame) string </span><span class="cov0" title="0">{
                        s := strings.Split(f.Function, ".")
                        funcName := s[len(s)-1]
                        var dir string
                        if idx := strings.Index(f.File, config.ProjectBaseDir); idx != -1 </span><span class="cov0" title="0">{
                                dir = f.File[idx+len(config.ProjectBaseDir):]
                        }</span> else<span class="cov0" title="0"> {
                                dir = f.File
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("[%s:%d @%s]", dir, f.Line, funcName)</span>
                },
        })

        <span class="cov0" title="0">if err = os.MkdirAll(config.LogsDir, 0777); err != nil </span><span class="cov0" title="0">{
                if os.IsExist(err) </span><span class="cov0" title="0">{
                        logrus.Fatalf("Error: Such path already exists")
                }</span>
                <span class="cov0" title="0">logrus.Fatalf("Error: create logs directory %v", err)</span>
        }

        <span class="cov0" title="0">f, err := os.OpenFile(logsFName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Error: open file %v", err)
        }</span>

        <span class="cov0" title="0">l.SetOutput(io.Discard)

        l.AddHook(&amp;logHook{
                Writers:   []io.Writer{f, os.Stdout},
                LogLevels: logrus.AllLevels,
        })

        l.SetLevel(logrus.InfoLevel)

        logEntry = logrus.NewEntry(l)</span>
}

type color uint8

const (
        Red    color = 31
        Yellow color = 33
        Cyan   color = 36
        Gray   color = 37
)

func (f *Formatter) printColored(b *bytes.Buffer, level logrus.Level, message string) <span class="cov0" title="0">{
        var levelColor color
        switch level </span>{
        case logrus.DebugLevel, logrus.TraceLevel:<span class="cov0" title="0">
                levelColor = Gray</span>
        case logrus.WarnLevel:<span class="cov0" title="0">
                levelColor = Yellow</span>
        case logrus.ErrorLevel, logrus.FatalLevel, logrus.PanicLevel:<span class="cov0" title="0">
                levelColor = Red</span>
        default:<span class="cov0" title="0">
                levelColor = Cyan</span>
        }
        <span class="cov0" title="0">_, err := fmt.Fprintf(b, "\x1b[%dm%s\x1b[0m", levelColor, message)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

type Formatter struct {
        TimeFormat            string
        Colors                bool
        Caller                bool
        LevelFirst            bool
        FieldsSpace           bool
        CustomCallerFormatter func(*runtime.Frame) string
}

func (f *Formatter) Format(entry *logrus.Entry) ([]byte, error) <span class="cov0" title="0">{
        if f.TimeFormat == "" </span><span class="cov0" title="0">{
                f.TimeFormat = time.RFC3339
        }</span>

        <span class="cov0" title="0">b := &amp;bytes.Buffer{}

        f.writeStringBrackets(b, entry.Time.Format(f.TimeFormat))
        if f.FieldsSpace </span><span class="cov0" title="0">{
                b.WriteString(" ")
        }</span>

        <span class="cov0" title="0">if !f.LevelFirst </span><span class="cov0" title="0">{
                if f.Caller </span><span class="cov0" title="0">{
                        f.writeCaller(b, entry)
                }</span>

                <span class="cov0" title="0">if f.FieldsSpace </span><span class="cov0" title="0">{
                        b.WriteString(" ")
                }</span>
        }

        <span class="cov0" title="0">level := strings.ToUpper(entry.Level.String())
        if f.Colors </span><span class="cov0" title="0">{
                f.printColored(b, entry.Level, f.getStringInBr(level))
        }</span> else<span class="cov0" title="0"> {
                f.writeStringBrackets(b, level)
        }</span>

        <span class="cov0" title="0">if f.FieldsSpace </span><span class="cov0" title="0">{
                b.WriteString(" ")
        }</span>

        <span class="cov0" title="0">f.writeFields(b, entry)

        if f.FieldsSpace </span><span class="cov0" title="0">{
                b.WriteString(" ")
        }</span>

        <span class="cov0" title="0">if f.LevelFirst </span><span class="cov0" title="0">{
                if f.Caller </span><span class="cov0" title="0">{
                        f.writeCaller(b, entry)
                }</span>

                <span class="cov0" title="0">if f.FieldsSpace </span><span class="cov0" title="0">{
                        b.WriteString(" ")
                }</span>
        }

        <span class="cov0" title="0">b.WriteString(strings.TrimSpace(entry.Message))
        b.WriteByte('\n')
        return b.Bytes(), nil</span>
}

func (f *Formatter) getStringInBr(message string) string <span class="cov0" title="0">{
        return fmt.Sprintf("[%s]", message)
}</span>

func (f *Formatter) writeStringBrackets(b *bytes.Buffer, message string) <span class="cov0" title="0">{
        b.WriteString(f.getStringInBr(message))
}</span>

func (f *Formatter) writeCaller(b *bytes.Buffer, entry *logrus.Entry) <span class="cov0" title="0">{
        if entry.HasCaller() </span><span class="cov0" title="0">{
                if f.CustomCallerFormatter != nil </span><span class="cov0" title="0">{
                        fmt.Fprint(b, f.CustomCallerFormatter(entry.Caller))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(
                                b,
                                "[%s:%d @%s]",
                                entry.Caller.File,
                                entry.Caller.Line,
                                entry.Caller.Function,
                        )
                }</span>
        }
}

func (f *Formatter) writeFields(b *bytes.Buffer, entry *logrus.Entry) <span class="cov0" title="0">{
        if len(entry.Data) != 0 </span><span class="cov0" title="0">{
                fields := make([]string, 0, len(entry.Data))
                for field := range entry.Data </span><span class="cov0" title="0">{
                        fields = append(fields, field)
                }</span>

                <span class="cov0" title="0">sort.Strings(fields)

                for _, field := range fields </span><span class="cov0" title="0">{
                        f.writeField(b, entry, field)
                }</span>
        }
}

func (f *Formatter) writeField(b *bytes.Buffer, entry *logrus.Entry, field string) <span class="cov0" title="0">{
        str := fmt.Sprintf("[%s:%v]", field, entry.Data[field])

        if f.FieldsSpace </span><span class="cov0" title="0">{
                str += " "
        }</span>
        <span class="cov0" title="0">if f.Colors </span><span class="cov0" title="0">{
                f.printColored(b, entry.Level, str)
        }</span> else<span class="cov0" title="0"> {
                b.WriteString(str)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package pkg

import (
        "crypto/rand"
        "math/big"
)

func String(length int) (string, error) <span class="cov10" title="3">{
        charSet := "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        randBytes := make([]byte, length)
        for i := range randBytes </span><span class="cov10" title="3">{
                res, err := rand.Int(rand.Reader, big.NewInt(int64(len(charSet))))
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov10" title="3">randBytes[i] = charSet[res.Int64()]</span>
        }
        <span class="cov10" title="3">return string(randBytes), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package pkg

import (
        "encoding/json"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg/errors"
        log "github.com/sirupsen/logrus"
        "net/http"
)

func SendJSON(w http.ResponseWriter, status int, dataStruct any) <span class="cov10" title="3">{
        dataJSON, err := json.Marshal(dataStruct)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to marshal", err)
                SendError(w, errors.NewWrappedErr(http.StatusInternalServerError, "failed to marshal", err))
                return
        }</span>

        <span class="cov10" title="3">w.Header().Set("Content-Type", ContentTypeJSON)
        w.WriteHeader(status)

        _, err = w.Write(dataJSON)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to send", err)
                SendError(w, errors.NewWrappedErr(http.StatusInternalServerError, "failed to send", err))
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package pkg

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "strings"
)

func ValidateLogin(login string) (string, error) <span class="cov10" title="2">{
        email := login
        if !strings.Contains(login, config.PostAtDomain) </span><span class="cov1" title="1">{
                if strings.Contains(login, "@") || strings.Contains(login, ".") </span><span class="cov0" title="0">{
                        return "", auth.ErrInvalidLogin
                }</span> else<span class="cov1" title="1"> {
                        email += config.PostAtDomain
                }</span>
        } else<span class="cov1" title="1"> {
                idx := strings.Index(login, config.PostAtDomain)
                if idx+len(config.PostAtDomain) &lt; len(login) ||
                        strings.Index(login, "@") &lt; idx || strings.Index(login, ".") &lt; idx </span><span class="cov0" title="0">{
                        return "", auth.ErrInvalidLogin
                }</span>
        }
        <span class="cov10" title="2">return email, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
