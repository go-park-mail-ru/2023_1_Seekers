
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-park-mail-ru/2023_1_Seekers/internal/auth/delivery/http/handler.go (75.7%)</option>
				
				<option value="file1">github.com/go-park-mail-ru/2023_1_Seekers/internal/auth/delivery/http/register.go (0.0%)</option>
				
				<option value="file2">github.com/go-park-mail-ru/2023_1_Seekers/internal/auth/repository/inmemory/session.go (73.9%)</option>
				
				<option value="file3">github.com/go-park-mail-ru/2023_1_Seekers/internal/auth/usecase/usecase.go (78.4%)</option>
				
				<option value="file4">github.com/go-park-mail-ru/2023_1_Seekers/internal/mail/delivery/handler.go (42.1%)</option>
				
				<option value="file5">github.com/go-park-mail-ru/2023_1_Seekers/internal/mail/delivery/register.go (0.0%)</option>
				
				<option value="file6">github.com/go-park-mail-ru/2023_1_Seekers/internal/mail/repository/inmemory/inmemory.go (84.5%)</option>
				
				<option value="file7">github.com/go-park-mail-ru/2023_1_Seekers/internal/mail/usecase/usecase.go (82.6%)</option>
				
				<option value="file8">github.com/go-park-mail-ru/2023_1_Seekers/internal/middleware/middleware.go (70.8%)</option>
				
				<option value="file9">github.com/go-park-mail-ru/2023_1_Seekers/internal/user/repository/inmemory/repository.go (72.4%)</option>
				
				<option value="file10">github.com/go-park-mail-ru/2023_1_Seekers/internal/user/usecase/usecase.go (55.6%)</option>
				
				<option value="file11">github.com/go-park-mail-ru/2023_1_Seekers/pkg/errors/errors.go (100.0%)</option>
				
				<option value="file12">github.com/go-park-mail-ru/2023_1_Seekers/pkg/rand.go (87.5%)</option>
				
				<option value="file13">github.com/go-park-mail-ru/2023_1_Seekers/pkg/send_error.go (100.0%)</option>
				
				<option value="file14">github.com/go-park-mail-ru/2023_1_Seekers/pkg/send_json.go (50.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package http

import (
        "encoding/json"
        "fmt"
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        _user "github.com/go-park-mail-ru/2023_1_Seekers/internal/user"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg/errors"
        log "github.com/sirupsen/logrus"
        "io"
        "net/http"
        "time"
)

type handlers struct {
        authUC auth.UseCaseI
        userUC _user.UseCaseI
}

func New(aUC auth.UseCaseI, uUC _user.UseCaseI) auth.HandlersI <span class="cov10" title="2">{
        return &amp;handlers{
                authUC: aUC,
                userUC: uUC,
        }
}</span>

func (h *handlers) SignUp(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        log.Info(r.Host, r.Header, r.Body)
        defer func(Body io.ReadCloser) </span><span class="cov1" title="1">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to close request: ", err)
                }</span>
        }(r.Body)

        <span class="cov1" title="1">form := models.FormSignUp{}
        err := json.NewDecoder(r.Body).Decode(&amp;form)
        if err != nil </span><span class="cov1" title="1">{
                authErr := errors.NewWrappedErr(auth.Errors[auth.ErrInvalidForm], auth.ErrInvalidForm.Error(), err)
                log.Error(authErr)
                pkg.SendError(w, authErr)
                return
        }</span>
        <span class="cov1" title="1">user, err := h.authUC.SignUp(form)
        if err != nil </span><span class="cov1" title="1">{
                if err == auth.ErrPwDontMatch </span><span class="cov1" title="1">{
                        authErr := errors.New(auth.Errors[auth.ErrPwDontMatch], auth.ErrPwDontMatch)
                        log.Error(authErr)
                        pkg.SendError(w, authErr)
                        return
                }</span>
                <span class="cov1" title="1">if err == _user.ErrTooShortPw </span><span class="cov0" title="0">{
                        authErr := errors.New(auth.Errors[_user.ErrTooShortPw], _user.ErrTooShortPw)
                        log.Error(authErr)
                        pkg.SendError(w, authErr)
                        return
                }</span>
                <span class="cov1" title="1">authErr := errors.NewWrappedErr(auth.Errors[auth.ErrFailedSignUp], auth.ErrFailedSignUp.Error(), err)
                log.Error(authErr)
                pkg.SendError(w, authErr)
                return</span>
        }

        <span class="cov1" title="1">profile := models.Profile{
                UID:       user.ID,
                FirstName: form.FirstName,
                LastName:  form.LastName,
                BirthDate: form.BirthDate,
        }
        err = h.userUC.CreateProfile(profile)
        if err != nil </span><span class="cov0" title="0">{
                authErr := errors.NewWrappedErr(auth.Errors[auth.ErrFailedCreateProfile], auth.ErrFailedCreateProfile.Error(), err)
                log.Error(authErr)
                pkg.SendError(w, authErr)
                return
        }</span>

        <span class="cov1" title="1">session, err := h.authUC.CreateSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                authErr := errors.NewWrappedErr(auth.Errors[auth.ErrFailedCreateSession], auth.ErrFailedCreateSession.Error(), err)
                log.Error(authErr)
                pkg.SendError(w, authErr)
                return
        }</span>

        <span class="cov1" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:    config.CookieName,
                Value:   session.SessionID,
                Expires: time.Now().Add(config.CookieTTL),
                Path:    config.CookiePath,
        })
        pkg.SendJSON(w, http.StatusOK, user)</span>
}

func (h *handlers) SignIn(w http.ResponseWriter, r *http.Request) <span class="cov10" title="2">{
        log.Info(r.Host, r.Header, r.Body)
        defer func(Body io.ReadCloser) </span><span class="cov10" title="2">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Errorf("failed to close request: %w", err))
                }</span>
        }(r.Body)
        <span class="cov10" title="2">form := models.FormLogin{}

        err := json.NewDecoder(r.Body).Decode(&amp;form)
        if err != nil </span><span class="cov1" title="1">{
                authErr := errors.NewWrappedErr(auth.Errors[auth.ErrInvalidForm], auth.ErrInvalidForm.Error(), err)
                log.Error(authErr)
                pkg.SendError(w, authErr)
                return
        }</span>

        <span class="cov10" title="2">user, err := h.authUC.SignIn(form)
        if err != nil </span><span class="cov1" title="1">{
                authErr := errors.NewWrappedErr(auth.Errors[auth.ErrFailedSignIn], auth.ErrFailedSignIn.Error(), err)
                log.Error(authErr)
                pkg.SendError(w, authErr)
                return
        }</span>

        // когда логинимся, то обновляем куку, если ранее была, то удалится и пересоздастся
        <span class="cov10" title="2">err = h.authUC.DeleteSessionByUID(user.ID)
        session, err := h.authUC.CreateSession(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                authErr := errors.NewWrappedErr(auth.Errors[auth.ErrFailedCreateSession], auth.ErrFailedCreateSession.Error(), err)
                log.Error(authErr)
                pkg.SendError(w, authErr)
                return
        }</span>

        <span class="cov10" title="2">http.SetCookie(w, &amp;http.Cookie{
                Name:    config.CookieName,
                Value:   session.SessionID,
                Expires: time.Now().Add(config.CookieTTL),
                Path:    config.CookiePath,
        })
        pkg.SendJSON(w, http.StatusOK, user)</span>
}

func (h *handlers) Logout(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        log.Info(r.Host, r.Header, r.Body)

        http.SetCookie(w, &amp;http.Cookie{
                Name:    config.CookieName,
                Value:   "",
                Expires: time.Now().AddDate(0, 0, -1),
                Path:    config.CookiePath,
        })

        w.WriteHeader(http.StatusOK)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package http

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/middleware"
        "github.com/gorilla/mux"
        "net/http"
)

func RegisterHTTPRoutes(r *mux.Router, h auth.HandlersI, m *middleware.Middleware) <span class="cov0" title="0">{
        r.HandleFunc(config.RouteSignin, h.SignIn).Methods(http.MethodPost)
        r.HandleFunc(config.RouteSignup, h.SignUp).Methods(http.MethodPost)
        r.HandleFunc(config.RouteLogout, m.CheckAuth(h.Logout)).Methods(http.MethodGet)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package inmemory

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
)

type sessionsDB struct {
        sessions []models.Session
}

func New() auth.RepoI <span class="cov10" title="3">{
        return &amp;sessionsDB{
                []models.Session{
                        {1, "randgeneratedcookie12334524524523542"}, //уже есть сессия для Uid 1
                },
        }
}</span>

func (sDb *sessionsDB) CreateSession(s models.Session) error <span class="cov6" title="2">{
        if _, err := sDb.GetSessionByUID(s.UID); err == nil </span><span class="cov0" title="0">{
                return auth.ErrSessionExists
        }</span>
        <span class="cov6" title="2">sDb.sessions = append(sDb.sessions, s)
        return nil</span>
}

func (sDb *sessionsDB) DeleteSession(sessionID string) error <span class="cov0" title="0">{
        for i, s := range sDb.sessions </span><span class="cov0" title="0">{
                if s.SessionID == sessionID </span><span class="cov0" title="0">{
                        sDb.sessions = append(sDb.sessions[:i], sDb.sessions[i+1:]...)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return auth.ErrSessionNotFound</span>
}

func (sDb *sessionsDB) DeleteSessionByUID(uID uint64) error <span class="cov6" title="2">{
        for i, s := range sDb.sessions </span><span class="cov6" title="2">{
                if s.UID == uID </span><span class="cov6" title="2">{
                        sDb.sessions = append(sDb.sessions[:i], sDb.sessions[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov1" title="1">return auth.ErrSessionNotFound</span>
}

func (sDb *sessionsDB) GetSession(sessionID string) (*models.Session, error) <span class="cov10" title="3">{
        for _, s := range sDb.sessions </span><span class="cov10" title="3">{
                if s.SessionID == sessionID </span><span class="cov10" title="3">{
                        return &amp;s, nil
                }</span>
        }
        <span class="cov6" title="2">return nil, auth.ErrSessionNotFound</span>
}

func (sDb *sessionsDB) GetSessionByUID(uID uint64) (*models.Session, error) <span class="cov6" title="2">{
        for _, s := range sDb.sessions </span><span class="cov6" title="2">{
                if s.UID == uID </span><span class="cov6" title="2">{
                        return &amp;s, nil
                }</span>
        }
        <span class="cov6" title="2">return nil, auth.ErrSessionNotFound</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package usecase

import (
        "errors"
        "fmt"
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        _user "github.com/go-park-mail-ru/2023_1_Seekers/internal/user"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg"
)

type useCase struct {
        authRepo auth.RepoI
        userUC   _user.UseCaseI
}

func New(ar auth.RepoI, uc _user.UseCaseI) auth.UseCaseI <span class="cov10" title="3">{
        return &amp;useCase{
                authRepo: ar,
                userUC:   uc,
        }
}</span>

func (u *useCase) SignIn(form models.FormLogin) (*models.User, error) <span class="cov6" title="2">{
        user, err := u.userUC.GetUserByEmail(form.Email)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("cant get user: %w", err)
        }</span>

        <span class="cov6" title="2">if user.Password != form.Password </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>

        <span class="cov6" title="2">return user, nil</span>
}

func (u *useCase) SignUp(form models.FormSignUp) (*models.User, error) <span class="cov1" title="1">{
        if form.RepeatPw != form.Password </span><span class="cov1" title="1">{
                return nil, auth.ErrPwDontMatch
        }</span>

        <span class="cov1" title="1">user, err := u.userUC.CreateUser(models.User{
                Email:    form.Email,
                Password: form.Password,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("cant create user: %w", err)
        }</span>

        <span class="cov1" title="1">return user, nil</span>
}

func (u *useCase) CreateSession(uID uint64) (*models.Session, error) <span class="cov6" title="2">{
        value, err := pkg.String(config.CookieLen)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cant create session: %w", err)
        }</span>
        <span class="cov6" title="2">newSession := models.Session{
                UID:       uID,
                SessionID: value,
        }

        err = u.authRepo.CreateSession(newSession)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cant create session: %w", err)
        }</span>

        <span class="cov6" title="2">return &amp;newSession, nil</span>
}

func (u *useCase) DeleteSession(sessionID string) error <span class="cov0" title="0">{
        err := u.authRepo.DeleteSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cant delete session: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (u *useCase) DeleteSessionByUID(uID uint64) error <span class="cov6" title="2">{
        err := u.authRepo.DeleteSessionByUID(uID)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("cant delete session by id: %w", err)
        }</span>

        <span class="cov6" title="2">return nil</span>
}

func (u *useCase) GetSession(sessionID string) (*models.Session, error) <span class="cov10" title="3">{
        s, err := u.authRepo.GetSession(sessionID)
        if err != nil </span><span class="cov6" title="2">{
                return nil, fmt.Errorf("cant get session: %w", err)
        }</span>

        <span class="cov10" title="3">return s, nil</span>
}

func (u *useCase) GetSessionByUID(uID uint64) (*models.Session, error) <span class="cov6" title="2">{
        s, err := u.authRepo.GetSessionByUID(uID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cant get session by user %w", err)
        }</span>

        <span class="cov6" title="2">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package delivery

import (
        "errors"
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/mail"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg"
        pkgErrors "github.com/go-park-mail-ru/2023_1_Seekers/pkg/errors"
        "github.com/gorilla/mux"
        log "github.com/sirupsen/logrus"
        "net/http"
        "strconv"
)

type delivery struct {
        uc mail.UseCaseI
}

func New(uc mail.UseCaseI) mail.HandlersI <span class="cov8" title="1">{
        return &amp;delivery{
                uc: uc,
        }
}</span>

func (del *delivery) GetInboxMessages(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                methodErr := pkgErrors.NewWrappedErr(mail.MailErrors[mail.ErrHttpGetMethod], mail.ErrHttpGetMethod.Error(), errors.New(r.Method+" request received"))
                log.Error(methodErr)
                pkg.SendError(w, methodErr)
                return
        }</span>

        <span class="cov8" title="1">userID, ok := r.Context().Value(config.ContextUser).(uint64)

        if !ok </span><span class="cov0" title="0">{
                methodErr := pkgErrors.New(mail.MailErrors[mail.ErrFailedGetUser], mail.ErrFailedGetUser)
                log.Error(methodErr)
                pkg.SendError(w, methodErr)
                return
        }</span>

        <span class="cov8" title="1">messages, err := del.uc.GetIncomingMessages(userID)

        if err != nil </span><span class="cov0" title="0">{
                mailErr := pkgErrors.NewWrappedErr(mail.MailErrors[mail.ErrFailedGetInboxMessages], mail.ErrFailedGetInboxMessages.Error(), err)
                log.Error(mailErr)
                pkg.SendError(w, mailErr)
                return
        }</span>

        <span class="cov8" title="1">pkg.SendJSON(w, http.StatusOK, messages)</span>
}

func (del *delivery) GetOutboxMessages(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                methodErr := pkgErrors.NewWrappedErr(mail.MailErrors[mail.ErrHttpGetMethod], mail.ErrHttpGetMethod.Error(), errors.New(r.Method+" request received"))
                log.Error(methodErr)
                pkg.SendError(w, methodErr)
                return
        }</span>

        <span class="cov8" title="1">userID, ok := r.Context().Value(config.ContextUser).(uint64)

        if !ok </span><span class="cov0" title="0">{
                methodErr := pkgErrors.New(mail.MailErrors[mail.ErrFailedGetUser], mail.ErrFailedGetUser)
                log.Error(methodErr)
                pkg.SendError(w, methodErr)
                return
        }</span>

        <span class="cov8" title="1">messages, err := del.uc.GetOutgoingMessages(userID)

        if err != nil </span><span class="cov0" title="0">{
                mailErr := pkgErrors.NewWrappedErr(mail.MailErrors[mail.ErrFailedGetOutboxMessages], mail.ErrFailedGetOutboxMessages.Error(), err)
                log.Error(mailErr)
                pkg.SendError(w, mailErr)
                return
        }</span>

        <span class="cov8" title="1">pkg.SendJSON(w, http.StatusOK, messages)</span>
}

func (del *delivery) GetFolderMessages(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                methodErr := pkgErrors.NewWrappedErr(mail.MailErrors[mail.ErrHttpGetMethod], mail.ErrHttpGetMethod.Error(), errors.New(r.Method+" request received"))
                log.Error(methodErr)
                pkg.SendError(w, methodErr)
                return
        }</span>

        <span class="cov8" title="1">userID, ok := r.Context().Value(config.ContextUser).(uint64)
        if !ok </span><span class="cov0" title="0">{
                methodErr := pkgErrors.New(mail.MailErrors[mail.ErrFailedGetUser], mail.ErrFailedGetUser)
                log.Error(methodErr)
                pkg.SendError(w, methodErr)
                return
        }</span>
        <span class="cov8" title="1">vars := mux.Vars(r)
        folderID, err := strconv.ParseUint(vars["id"], 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                mailErr := pkgErrors.NewWrappedErr(mail.MailErrors[mail.ErrInvalidURL], mail.ErrInvalidURL.Error(), err)
                log.Error(mailErr)
                pkg.SendError(w, mailErr)
                return
        }</span>

        <span class="cov8" title="1">messages, err := del.uc.GetFolderMessages(userID, folderID)

        if err != nil </span><span class="cov8" title="1">{
                mailErr := pkgErrors.NewWrappedErr(mail.MailErrors[mail.ErrFailedGetFolderMessages], mail.ErrFailedGetFolderMessages.Error(), err)
                log.Error(mailErr)
                pkg.SendError(w, mailErr)
                return
        }</span>

        <span class="cov8" title="1">pkg.SendJSON(w, http.StatusOK, messages)</span>
}

func (del *delivery) GetFolders(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Access-Control-Allow-Methods", "GET")

        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                methodErr := pkgErrors.NewWrappedErr(mail.MailErrors[mail.ErrHttpGetMethod], mail.ErrHttpGetMethod.Error(), errors.New(r.Method+" request received"))
                log.Error(methodErr)
                pkg.SendError(w, methodErr)
                return
        }</span>

        <span class="cov8" title="1">userID, ok := r.Context().Value(config.ContextUser).(uint64)

        if !ok </span><span class="cov0" title="0">{
                methodErr := pkgErrors.New(mail.MailErrors[mail.ErrFailedGetUser], mail.ErrFailedGetUser)
                log.Error(methodErr)
                pkg.SendError(w, methodErr)
                return
        }</span>

        <span class="cov8" title="1">folders := del.uc.GetFolders(userID)
        pkg.SendJSON(w, http.StatusOK, folders)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package delivery

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/mail"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/middleware"
        "github.com/gorilla/mux"
        "net/http"
)

func RegisterHTTPRoutes(r *mux.Router, h mail.HandlersI, m *middleware.Middleware) <span class="cov0" title="0">{
        r.HandleFunc(config.RouteInboxMessages, m.CheckAuth(h.GetInboxMessages)).Methods(http.MethodGet)
        r.HandleFunc(config.RouteOutboxMessages, m.CheckAuth(h.GetOutboxMessages)).Methods(http.MethodGet)
        r.HandleFunc(config.RouteFolderMessages, m.CheckAuth(h.GetFolderMessages)).Methods(http.MethodGet)
        r.HandleFunc(config.RouteFolders, m.CheckAuth(h.GetFolders)).Methods(http.MethodGet)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package inmemory

import (
        "errors"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/mail"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        _user "github.com/go-park-mail-ru/2023_1_Seekers/internal/user"
        "golang.org/x/exp/slices"
)

type mailDB struct {
        messages   []models.Message
        recipients []models.Recipient
        folders    []models.Folder
        boxes      []models.Box
        states     []models.State
        usersRepo  _user.RepoI
}

func New(ur _user.RepoI) mail.RepoI <span class="cov8" title="1">{
        return &amp;mailDB{
                messages: []models.Message{
                        {1, 1, "2023-01-01", "Invitation", "Hello, we decided to invite you to our party, lets go it will be fine!"},
                        {2, 1, "2023-01-02", "Spam letter", "Nunc non velit commodo, vestibulum enim ullamcorper, lobortis mi. Integer eu elit nibh. Integer bibendum semper arcu, eget consectetur nisi gravida eu. Suspendisse maximus id urna a volutpat. Quisque nec iaculis purus, non facilisis massa. Maecenas finibus dui ipsum, ut tempor sapien tincidunt blandit. Ut at iaculis eros, ultrices iaculis nibh. Mauris fermentum elit erat, at cursus urna euismod vel. In congue, ipsum a fermentum semper, dolor sem scelerisque leo, a tempus risus orci eu leo. Fusce vulputate venenatis imperdiet. Vestibulum interdum pellentesque facilisis"},
                        {3, 1, "2023-01-04", "Lorem", "Mauris imperdiet massa ante. Pellentesque feugiat nisl nec ultrices laoreet. Aenean a mauris mi. Sed auctor egestas nulla et vulputate. Praesent lobortis nulla ante, vel dignissim odio aliquet et. Suspendisse potenti. Donec venenatis nibh a sem consectetur, bibendum consectetur metus venenatis. Mauris lorem tellus, finibus id dui sit amet, facilisis fermentum orci. Mauris arcu ante, lacinia vitae orci in, tempus elementum lacus. Donec eu augue vulputate, tempor neque nec, efficitur purus. Mauris ut lorem non sapien placerat mattis. In in lacus a lorem viverra laoreet ut et orci. Maecenas auctor, justo nec hendrerit interdum, nibh nisi consectetur sapien, id ultrices lacus mi sed risus. "},
                        {4, 1, "2023-01-05", "Very interesting letter", "Morbi sit amet porttitor sapien, eget venenatis est. Suspendisse sollicitudin elit velit, quis sodales dolor maximus id. Vestibulum gravida scelerisque nibh, sit amet tincidunt augue gravida nec. Maecenas non placerat justo, at feugiat nulla. Phasellus dapibus a mi ut interdum. Aliquam nec quam feugiat, rutrum urna ut, cursus purus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. "},
                        {5, 1, "2023-01-06", "Small text letter", "Hi! how are you?"},
                        {5, 1, "2023-01-06", "Title", "Open this letter please"},
                        {6, 1, "2023-01-07", "Advertisement", "Hi, visit our shop!"},
                        {7, 2, "2023-01-29", "Title2", "Text2"},
                        {8, 2, "2023-01-29", "Title3", "Text3"},
                        {9, 3, "2023-01-01", "Title4", "Text4"},
                        //{5, 2, "2023-03-01", "Title5", "Text5"},
                },
                recipients: []models.Recipient{
                        {1, 2},
                        {2, 3},
                        {3, 2},
                        {4, 3},
                        {4, 2},
                        {5, 2},
                        {5, 3},
                        {6, 2},
                        {7, 3},
                        {8, 1},
                        {9, 1},
                },
                folders: []models.Folder{
                        {1, "Trash", 1},
                        {2, "Spam", 1},
                        {3, "Trash", 2},
                        {4, "Spam", 2},
                        {5, "Trash", 3},
                        {6, "Spam", 3},
                        {7, "My", 2},
                        {8, "Empty", 3},
                        {5, "Trash", 4},
                        {6, "Spam", 4},
                },
                boxes: []models.Box{
                        {7, 1},
                },
                states: []models.State{
                        {2, 1, false, false, true},
                        {1, 1, true, false, true},
                        {3, 2, false, false, true},
                        {1, 2, true, false, true},
                        {2, 3, false, false, true},
                        {1, 3, true, false, true},
                        {3, 4, false, false, true},
                        {2, 4, false, false, true},
                        {1, 4, true, false, true},
                        {2, 5, false, false, true},
                        {3, 5, false, false, true},
                        {1, 5, true, false, true},
                        {2, 6, false, false, true},
                        {1, 6, true, false, true},
                        {3, 7, false, false, true},
                        {2, 7, true, false, true},
                        {1, 8, false, false, true},
                        {2, 8, true, false, true},
                        {1, 9, false, false, true},
                        {3, 9, true, false, true},
                        {3, 2, true, false, true},
                        {1, 3, false, false, true},
                        {2, 4, false, false, true},
                        {1, 4, false, false, true},
                        {1, 2, true, false, true},
                        {2, 3, true, false, true},
                        {3, 4, true, false, true},
                },
                usersRepo: ur,
        }
}</span>

func (db *mailDB) messageHasFolder(userID uint64, messageID uint64) bool <span class="cov8" title="1">{
        for _, b := range db.boxes </span><span class="cov8" title="1">{
                if b.MessageID == messageID </span><span class="cov8" title="1">{
                        idx := slices.IndexFunc(db.folders, func(folder models.Folder) bool </span><span class="cov8" title="1">{
                                return folder.FolderID == b.FolderID
                        }</span>)

                        <span class="cov8" title="1">if idx != -1 &amp;&amp; db.folders[idx].UserID == userID </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

func (db *mailDB) findOriginalMessage(messageID uint64) (*models.Message, error) <span class="cov8" title="1">{
        idx := slices.IndexFunc(db.messages, func(message models.Message) bool </span><span class="cov8" title="1">{
                return message.MessageID == messageID
        }</span>)

        <span class="cov8" title="1">if idx == -1 </span><span class="cov0" title="0">{
                return nil, errors.New("message not found")
        }</span>

        <span class="cov8" title="1">return &amp;db.messages[idx], nil</span>
}

func (db *mailDB) findState(userID uint64, messageID uint64) (*models.State, error) <span class="cov8" title="1">{
        idx := slices.IndexFunc(db.states, func(state models.State) bool </span><span class="cov8" title="1">{
                return state.UserID == userID &amp;&amp; state.MessageID == messageID
        }</span>)

        <span class="cov8" title="1">if idx == -1 </span><span class="cov0" title="0">{
                return nil, errors.New("state not found")
        }</span>

        <span class="cov8" title="1">return &amp;db.states[idx], nil</span>
}

func (db *mailDB) findRecipientsEmails(messageID uint64) ([]string, error) <span class="cov8" title="1">{
        var recipientsEmails []string

        for _, r := range db.recipients </span><span class="cov8" title="1">{
                if r.MessageID == messageID </span><span class="cov8" title="1">{
                        user, err := db.usersRepo.GetUserByID(r.UserID)

                        if err != nil </span><span class="cov0" title="0">{
                                return recipientsEmails, err
                        }</span>

                        <span class="cov8" title="1">recipientsEmails = append(recipientsEmails, user.Email)</span>
                }
        }

        <span class="cov8" title="1">return recipientsEmails, nil</span>
}

func (db *mailDB) SelectIncomingMessagesByUser(userID uint64) ([]models.IncomingMessage, error) <span class="cov8" title="1">{
        var messages []models.IncomingMessage

        for _, r := range db.recipients </span><span class="cov8" title="1">{
                if r.UserID == userID </span><span class="cov8" title="1">{
                        if db.messageHasFolder(r.UserID, r.MessageID) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">originalMessage, err := db.findOriginalMessage(r.MessageID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov8" title="1">fromUser, err := db.usersRepo.GetUserByID(originalMessage.UserID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov8" title="1">state, err := db.findState(r.UserID, r.MessageID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov8" title="1">currentMessage := models.IncomingMessage{
                                MessageID:    r.MessageID,
                                FromUser:     fromUser.Email,
                                CreatingDate: originalMessage.CreatingDate,
                                Title:        originalMessage.Title,
                                Text:         originalMessage.Text,
                                Read:         state.Read,
                                Favorite:     state.Favorite,
                        }

                        messages = append(messages, currentMessage)</span>
                }
        }

        <span class="cov8" title="1">return messages, nil</span>
}

func (db *mailDB) SelectOutgoingMessagesByUser(userID uint64) ([]models.OutgoingMessage, error) <span class="cov8" title="1">{
        var messages []models.OutgoingMessage

        for _, m := range db.messages </span><span class="cov8" title="1">{
                if m.UserID == userID </span><span class="cov8" title="1">{
                        if db.messageHasFolder(userID, m.MessageID) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">recipients, err := db.findRecipientsEmails(m.MessageID)

                        if len(recipients) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">state, err := db.findState(userID, m.MessageID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov8" title="1">currentMessage := models.OutgoingMessage{
                                MessageID:    m.MessageID,
                                ToUsers:      recipients,
                                CreatingDate: m.CreatingDate,
                                Title:        m.Title,
                                Text:         m.Text,
                                Read:         state.Read,
                                Favorite:     state.Favorite,
                        }

                        messages = append(messages, currentMessage)</span>
                }
        }

        <span class="cov8" title="1">return messages, nil</span>
}

func (db *mailDB) SelectFolderByUserNFolder(userID uint64, folderID uint64) (*models.Folder, error) <span class="cov8" title="1">{
        idx := slices.IndexFunc(db.folders, func(folder models.Folder) bool </span><span class="cov8" title="1">{
                return folder.UserID == userID &amp;&amp; folder.FolderID == folderID
        }</span>)

        <span class="cov8" title="1">if idx == -1 </span><span class="cov8" title="1">{
                return nil, errors.New("folder not found")
        }</span>

        <span class="cov8" title="1">return &amp;db.folders[idx], nil</span>
}

func (db *mailDB) SelectFoldersByUser(userID uint64) []models.Folder <span class="cov8" title="1">{
        var folders []models.Folder

        for _, f := range db.folders </span><span class="cov8" title="1">{
                if f.UserID == userID </span><span class="cov8" title="1">{
                        folders = append(folders, f)
                }</span>
        }

        <span class="cov8" title="1">return folders</span>
}

func (db *mailDB) SelectMessagesByUserNFolder(userID uint64, folderID uint64) ([]models.IncomingMessage, error) <span class="cov8" title="1">{
        var messages []models.IncomingMessage

        for _, b := range db.boxes </span><span class="cov8" title="1">{
                if b.FolderID == folderID </span><span class="cov8" title="1">{
                        originalMessage, err := db.findOriginalMessage(b.MessageID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov8" title="1">fromUser, err := db.usersRepo.GetUserByID(originalMessage.UserID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov8" title="1">state, err := db.findState(userID, b.MessageID)

                        if err != nil </span><span class="cov0" title="0">{
                                return messages, err
                        }</span>

                        <span class="cov8" title="1">currentMessage := models.IncomingMessage{
                                MessageID:    b.MessageID,
                                FromUser:     fromUser.Email,
                                CreatingDate: originalMessage.CreatingDate,
                                Title:        originalMessage.Title,
                                Text:         originalMessage.Text,
                                Read:         state.Read,
                                Favorite:     state.Favorite,
                        }

                        messages = append(messages, currentMessage)</span>
                }
        }

        <span class="cov8" title="1">return messages, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package usecase

import (
        "errors"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/mail"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
)

type UseCase struct {
        repo mail.RepoI
}

func New(rep mail.RepoI) mail.UseCaseI <span class="cov8" title="1">{
        return &amp;UseCase{
                repo: rep,
        }
}</span>

func (uc *UseCase) GetFolders(userID uint64) []models.Folder <span class="cov8" title="1">{
        folders := uc.repo.SelectFoldersByUser(userID)

        return folders
}</span>

func (uc *UseCase) GetIncomingMessages(userID uint64) ([]models.IncomingMessage, error) <span class="cov8" title="1">{
        var messages []models.IncomingMessage
        messages, err := uc.repo.SelectIncomingMessagesByUser(userID)

        if err != nil </span><span class="cov0" title="0">{
                return messages, err
        }</span>

        <span class="cov8" title="1">return messages, nil</span>
}

func (uc *UseCase) GetOutgoingMessages(userID uint64) ([]models.OutgoingMessage, error) <span class="cov8" title="1">{
        var messages []models.OutgoingMessage
        messages, err := uc.repo.SelectOutgoingMessagesByUser(userID)

        if err != nil </span><span class="cov0" title="0">{
                return messages, err
        }</span>

        <span class="cov8" title="1">return messages, nil</span>
}

func (uc *UseCase) GetFolderMessages(userID uint64, folderID uint64) ([]models.IncomingMessage, error) <span class="cov8" title="1">{
        var messages []models.IncomingMessage

        folder, err := uc.repo.SelectFolderByUserNFolder(userID, folderID)

        if err != nil </span><span class="cov8" title="1">{
                return messages, err
        }</span>

        <span class="cov8" title="1">if folder == nil </span><span class="cov0" title="0">{
                return messages, errors.New("folder not found")
        }</span>

        <span class="cov8" title="1">messages, err = uc.repo.SelectMessagesByUserNFolder(userID, folderID)

        if err != nil </span><span class="cov0" title="0">{
                return messages, err
        }</span>

        <span class="cov8" title="1">return messages, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "context"
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg/errors"
        log "github.com/sirupsen/logrus"
        "net/http"
)

type Middleware struct {
        uc auth.UseCaseI
}

func New(aUc auth.UseCaseI) *Middleware <span class="cov10" title="3">{
        return &amp;Middleware{aUc}
}</span>

func (m *Middleware) Cors(h http.Handler) http.Handler <span class="cov0" title="0">{
        handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type,access-control-allow-origin, access-control-allow-headers, Content-Length, X-CSRF-Token")
                w.Header().Set("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE")
                w.Header().Set("Access-Control-Allow-Credentials", "true")
                h.ServeHTTP(w, r)
        }</span>)
        <span class="cov0" title="0">return handler</span>

        //c := cors.New(cors.Options{
        //        AllowedOrigins:   []string{"http://localhost:8001"},
        //        AllowCredentials: true,
        //        Debug:            false,
        //})
        //return c.Handler(h)
}

func (m *Middleware) CheckAuth(h http.HandlerFunc) http.HandlerFunc <span class="cov10" title="3">{
        handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="3">{
                cookie, err := r.Cookie(config.CookieName)
                if err != nil </span><span class="cov6" title="2">{
                        authErr := errors.NewWrappedErr(auth.Errors[auth.ErrFailedAuth], auth.ErrFailedAuth.Error(), err)
                        log.Error(authErr)
                        pkg.SendError(w, authErr)
                        return
                }</span>
                <span class="cov10" title="3">session, err := m.uc.GetSession(cookie.Value)
                if err != nil </span><span class="cov6" title="2">{
                        authErr := errors.NewWrappedErr(auth.Errors[auth.ErrFailedGetSession], auth.ErrFailedGetSession.Error(), err)
                        log.Error(authErr)
                        pkg.SendError(w, authErr)
                        return
                }</span>

                <span class="cov10" title="3">r = r.WithContext(context.WithValue(r.Context(), config.ContextUser, session.UID))

                h.ServeHTTP(w, r)</span>
        })
        <span class="cov10" title="3">return handler</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package inmemory

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/auth"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/user"
)

type usersDB struct {
        users    []models.User
        profiles []models.Profile
}

func New() user.RepoI <span class="cov10" title="3">{
        return &amp;usersDB{
                []models.User{
                        {1, "test@example.com", "12345"},
                        {2, "gena@example.com", "54321"},
                        {3, "max@example.com", "13795"},
                        {4, "valera@example.com", "12345"},
                },
                []models.Profile{
                        {1, "Michail", "Testov", "21.12.2001"},
                        {2, "Ivan", "Ivanov", "21.12.2001"},
                        {3, "Michail", "Sidorov", "21.12.2001"},
                },
        }
}</span>

func (uDb *usersDB) GetUserByID(id uint64) (*models.User, error) <span class="cov1" title="1">{
        for i, u := range uDb.users </span><span class="cov1" title="1">{
                if u.ID == id </span><span class="cov1" title="1">{
                        return &amp;uDb.users[i], nil
                }</span>
        }
        <span class="cov0" title="0">return nil, auth.ErrUserNotFound</span>
}

func (uDb *usersDB) GetUserByEmail(email string) (*models.User, error) <span class="cov6" title="2">{
        for i, u := range uDb.users </span><span class="cov6" title="2">{
                if u.Email == email </span><span class="cov6" title="2">{
                        return &amp;uDb.users[i], nil
                }</span>
        }
        <span class="cov1" title="1">return nil, auth.ErrUserNotFound</span>
}

func (uDb *usersDB) CreateUser(user models.User) (*models.User, error) <span class="cov1" title="1">{
        _, err := uDb.GetUserByEmail(user.Email)
        if err == nil </span><span class="cov1" title="1">{
                return nil, auth.ErrUserExists
        }</span>
        //слой бд отвечает за присваивание id
        // TODO hash pw
        <span class="cov1" title="1">user.ID = uint64(len(uDb.users) + 1)
        uDb.users = append(uDb.users, user)
        return &amp;user, nil</span>
}

func (uDb *usersDB) DeleteUser(user models.User) error <span class="cov0" title="0">{
        for i, u := range uDb.users </span><span class="cov0" title="0">{
                if u.ID == user.ID </span><span class="cov0" title="0">{
                        uDb.users = append(uDb.users[:i], uDb.users[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return auth.ErrUserNotFound</span>
}

func (uDb *usersDB) GetProfileByID(id uint64) (*models.Profile, error) <span class="cov1" title="1">{
        for i, p := range uDb.profiles </span><span class="cov1" title="1">{
                if p.UID == id </span><span class="cov0" title="0">{
                        return &amp;uDb.profiles[i], nil
                }</span>
        }
        <span class="cov1" title="1">return nil, user.ErrUserNotFound</span>
}

func (uDb *usersDB) CreateProfile(profile models.Profile) error <span class="cov1" title="1">{
        _, err := uDb.GetProfileByID(profile.UID)
        if err == nil </span><span class="cov0" title="0">{
                return user.ErrUserExists
        }</span>
        <span class="cov1" title="1">uDb.profiles = append(uDb.profiles, profile)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package usecase

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/internal/models"
        _user "github.com/go-park-mail-ru/2023_1_Seekers/internal/user"
)

type useCase struct {
        userRepo _user.RepoI
}

func New(r _user.RepoI) _user.UseCaseI <span class="cov10" title="3">{
        return &amp;useCase{userRepo: r}
}</span>

func (u *useCase) CreateUser(user models.User) (*models.User, error) <span class="cov1" title="1">{
        if len(user.Password) &lt; config.PasswordMinLen </span><span class="cov0" title="0">{
                return nil, _user.ErrTooShortPw
        }</span>
        <span class="cov1" title="1">return u.userRepo.CreateUser(user)</span>
}

func (u *useCase) DeleteUser(user models.User) error <span class="cov0" title="0">{
        return u.userRepo.DeleteUser(user)
}</span>

func (u *useCase) GetUserByID(ID uint64) (*models.User, error) <span class="cov0" title="0">{
        return u.userRepo.GetUserByID(ID)
}</span>

func (u *useCase) GetUserByEmail(email string) (*models.User, error) <span class="cov6" title="2">{
        return u.userRepo.GetUserByEmail(email)
}</span>

func (u *useCase) CreateProfile(profile models.Profile) error <span class="cov1" title="1">{
        // TODO some profile validation
        return u.userRepo.CreateProfile(profile)
}</span>
func (u *useCase) GetProfileByID(id uint64) (*models.Profile, error) <span class="cov0" title="0">{
        return u.userRepo.GetProfileByID(id)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package errors

type JSONError struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

func (err *JSONError) Error() string <span class="cov10" title="3">{
        return err.Message
}</span>

func New(code int, err error) *JSONError <span class="cov1" title="1">{
        return &amp;JSONError{
                Code:    code,
                Message: err.Error(),
        }
}</span>

func NewWrappedErr(code int, message string, err error) *JSONError <span class="cov10" title="3">{
        return &amp;JSONError{
                Code:    code,
                Message: message + " : " + err.Error(),
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package pkg

import (
        "crypto/rand"
        "math/big"
)

func String(length int) (string, error) <span class="cov10" title="3">{
        charSet := "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        randBytes := make([]byte, length)
        for i := range randBytes </span><span class="cov10" title="3">{
                res, err := rand.Int(rand.Reader, big.NewInt(int64(len(charSet))))
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov10" title="3">randBytes[i] = charSet[res.Int64()]</span>
        }
        <span class="cov10" title="3">return string(randBytes), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package pkg

import (
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg/errors"
        "net/http"
)

func SendError(w http.ResponseWriter, error *errors.JSONError) <span class="cov10" title="3">{
        SendJSON(w, error.Code, error)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package pkg

import (
        "encoding/json"
        "github.com/go-park-mail-ru/2023_1_Seekers/cmd/config"
        "github.com/go-park-mail-ru/2023_1_Seekers/pkg/errors"
        log "github.com/sirupsen/logrus"
        "net/http"
)

func SendJSON(w http.ResponseWriter, status int, dataStruct any) <span class="cov10" title="3">{
        dataJSON, err := json.Marshal(dataStruct)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to marshal", err)
                SendError(w, errors.NewWrappedErr(http.StatusInternalServerError, "failed to marshal", err))
                return
        }</span>

        <span class="cov10" title="3">w.Header().Set("Content-Type", config.ContentTypeJSON)
        w.WriteHeader(status)

        _, err = w.Write(dataJSON)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to send", err)
                SendError(w, errors.NewWrappedErr(http.StatusInternalServerError, "failed to send", err))
                return
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
